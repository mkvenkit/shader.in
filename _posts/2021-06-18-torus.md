---
layout: post
title: "Rendering a Torus: Geometry, Lighting, and Textures"
excerpt: "...torus."
tags: [OpenGL, C++, rendering, GLSL, shader, fragment, vertex, normal mapping, bump mapping, phong, gouraud, parameteric equation]
categories: [3D Graphics, programming]
comments: false
modified: 2021-06-19
thumbnail: /images/2021/06/torus_tn.png
---

![torus](/images/2021/06/torus.png)

# Introduction 

OpenGL 

Vulkan...


# Objective 

In this project we will render a torus using the OpenGL. 

These are the topics we will be covering in this article:

- [Project Overview](#project-overview)
- Modern OpenGL Code Structure
- Creating Axis and Plane 
- Creating the torus geometry 
- Lighting Model 
    - Gouraud Shading
    - Phong Shading 
    - Rim Lighting
- Texture Mapping 
- Procedura Textures  
- Bump Mapping 

I'll assume that you have some background in C++ and OpenGL. In my articles, I'll be mostly focusing on the math and explanation of graphics techniques. The full code listings can be found in the link in the [Downloads](#downloads) section.

Now let's get started.

# Project Overview 

We will use C++ 17 and OpenGL for this project. We will also leverage the following external 
libraries:

- [GLFW][1] - a cross platform OpenGL windowing library.
- [glad][2] - a OpenGL function loader. (Incuded in repo.)
- [glm][3] - an amazing C++ headers-only GLSL compatible library for 3D graphics math.
- [stb][4] - a single file image loading library. (Included in repo.)

This project uses CMake for builds. The code is structured as follows:

- **src/common** contains the following common classes used by the projects:
    -  **Axis3D** - draws X/Y/Z axes 
    -  **Plane** - draws an XY plane of given dimensions
    -  **Render3D** - base class for graphics objects
    -  **RenderApp** - base class for GLFW based application
    - **Utils** - utilities like GLSL program loading, texture loading, etc.
- **src/torus** has the following:
    - **TorusApp** - derives from **RenderApp** - manages GLFW 
    - **Torus** - derives from **Render3D** - torus rendering code 
    - **main.cpp** - creates the **TorusApp** object  
- **shaders/** - directory that contains all the GLSL shader files

This project is part of my *Notes on Computer Graphics* initiative. Please check the 
[Downloads](#downloads) link for more details.

# OpenGL Setup

We will be using OpenGL 4.5 for this projects. Here's the overall rendering strategy, which is typical for OpenGL programs.

**Setup**

1. Load the required GLSL shaders. 
2. Create the geometry for the 3D object - vertices, normals, texture coordinates, etc.
3. Load textures, if applicable.
4. Create a Vertex Array Object (VAO) for 
5. Create a VBO

**Render**

1. Update Projection, View, Model, and Normal matrices as applicable.
2. Enable GLSL program, update *uniform* data.
3. Render the object using *glDrawArrays()* or similar calls.


# Torus Geometry 

A torus centered at the origin with its axis aligned along $$+Z$$ can be described using the following set of parametric equations:

$$
\begin{aligned}
x &= (R + r \cos{v}) \cos{u} \\
y &= (R + r \cos{v}) \sin{u} \\
z &= r \sin{v} \\
&u, v \in [0, 2\pi]
\end{aligned}
\tag{1}
$$

In Eq. 1, $$R$$ is the outer radius of the torus, $$r$$ is the tube radius.
$$u$$ goes from $$0$$ to $$2\pi$$, creating the outer ring of the torus, and $$v$$ goes 
from $$0$$ to $$2\pi$$ creating the inner tube of the torus.

<hr>
## Derivation 

Since a picture is worth a thousand words or so, here's a quick visual proof of the above:

![torus param deriv](/images/2021/06/torus_param.png)

<hr>

The surface normal for a point $$(x, y, z)$$ on the torus is given by the following set of parametric equations:

$$
\begin{aligned}
N_x &= \cos{v} \cos{u} \\
N_y &= \cos{v} \sin{u} \\
N_z &= \sin{v}
\end{aligned}
\tag{2}
$$

To get some intution on Eq. 2, think about the direction of the normals on a circular ring on the torus. They will be the same even if the ring is translated to the origin. Also, remember that normal at a point $$P=(x, y)$$ on a unit circle is $$N=(x, y)$$. So if you set $$R=0$$ and $$r=1$$ in Eq. 1, you end up with Eq. 2.

## Tangent Space

The parameters $$(u, v)$$ form an important coordinate system for rendering our torus. Normalising them gives us texture coordinates - also commonly expressed as $$(s, t)$$. They are also used in ligting, and that's where the notion of **tangent space** comes in. 




Here's the scheme we're going to use to render the torus:

![torus construction](/images/2021/06/torus_render.png)

## Code

Here's the code, from the *Torus::_createTorus()* method which computes the vertices, normals, and tangents. 

```cpp
float du = 2 * M_PI / _nR;
float dv = 2 * M_PI / _nr;

for (size_t i = 0; i < _nR; i++) {

    float u = i * du;

    for (size_t j = 0; j <= _nr; j++) {

        float v = (j % _nr) * dv;

        for (size_t k = 0; k < 2; k++)
        {
            float uu = u + k * du;
            // compute vertex
            float x = (_R + _r * cos(v)) * cos(uu);
            float y = (_R + _r * cos(v)) * sin(uu);
            float z = _r * sin(v);

            // add vertex 
            _vertices.push_back(x);
            _vertices.push_back(y);
            _vertices.push_back(z);

            // compute normal 
            float nx = cos(v) * cos(uu);
            float ny = cos(v) * sin(uu);
            float nz = sin(v);

            // add normal 
            _normals.push_back(nx);
            _normals.push_back(ny);
            _normals.push_back(nz);

            // compute texture coords
            float tx = uu / (2 * M_PI);
            float ty = v / (2 * M_PI);

            // add tex coords
            _texCoords.push_back(tx);
            _texCoords.push_back(ty);

            // add tangent vector
            // T = d(S)/du 
            // S(u) is the circle at constant v
            glm::vec3 tg(  -(_R + _r * cos(v)) * sin(uu),
                            (_R + _r * cos(v)) * cos(uu),
                            0.0f
                        );
            tg = glm::normalize(tg);
            _tangents.push_back(tg.x);
            _tangents.push_back(tg.y);
            _tangents.push_back(tg.z);
        }
        // incr angle
        v += dv;
    }
}
```


# Lighting Model 

Here's the lighting model for our project.

![Lighting Model](/images/2021/06/lighting.png)



# Gouraud Shading 

## Normal Matrix 

- compute in cpp 

Here's the vertex shader:

```c
#version 450 core

layout(location = 0) in vec3 aVert;
layout(location = 1) in vec3 aNorm;

uniform mat4 vMat;
uniform mat4 pMat;
uniform mat4 mMat;

out vec3 color;
out vec3 norm;


void main()
{
    // vertex in world coords
    vec3 wcVert = (vMat * mMat * vec4(aVert, 1.0)).xyz;
    // normal in world coords
    mat4 nMat = transpose(inverse(vMat * mMat));
    vec3 N = normalize((nMat * vec4(aNorm, 1.0)).xyz);

    // ambient 
    vec3 camb = vec3(0.1);

    // diffuse 
    vec3 lightPos = vec3(0.0, 0.0, 10.0);
    vec3 L = normalize(lightPos - wcVert);
    float diff = max(dot(N, L), 0.0);
    vec3 Ka = vec3(1.0, 0.0, 0.0);
    float Ia = 0.5;
    vec3 cdiff = diff*Ka*Ia;

    // specular 
    vec3 Ks = vec3(1.0, 1.0, 1.0);
    float Is = 1.0;
    vec3 R = reflect(-L, N);
    vec3 V = normalize(-wcVert);
    float a = 128.0;
    float spec = pow(max(dot(R, V), 0.0), a);
    vec3 cspec = spec*Ks*Is;

    // final color 
    color = camb  + cdiff  + cspec;

    gl_Position = pMat * vMat * mMat * vec4(aVert, 1.0);

    norm = aNorm;	
}
```

Here's the fragment shader:

```c
#version 450 core

in vec3 color;
out vec4 fragColor;

void main()
{
    fragColor = vec4(color, 1.0);    
}
```


# Phong Shading 

# Rim Lighting 

# Texture Mapping 

For simple texture mapping, we're just going to load an image and drape it over the torus. Our texture coordinates *(s, t)* are just the normalized *(u, v)* coordinates. So *(s, t)* is in the range *[0, 1]*. What if you want to tile (repeat) a texture across the torus? Then all you need to do is change the texture coordinates. For example, *(4*s, 2*t)* will repeat the texture 4 times in the *u* direction and 2 times in the *v* direction. (You also need to ensure that you specify *GL_REPEAT* when you setup the texture using *glTexParameter*.)

The vertex shader for the texturing is the same as the one we used for Phong shading. Here's what the fragment shader for texturing looks like:

```c
#version 450 core

uniform bool enableRimLight;
uniform sampler2D sampler;

in VS_OUT {
	in vec3 N;
	in vec3 L;
	in vec3 V;
	in vec2 tc;
} fs_in;

out vec4 color;

void main()
{
	// normalise vectors
	vec3 N = normalize(fs_in.N);
	vec3 L = normalize(fs_in.L);
	vec3 V = normalize(fs_in.V);

	// ambient 
	vec3 camb = vec3(0.1);

	// texture 
	vec3 texCol = texture(sampler, fs_in.tc).xyz;

	// diffuse 
    float diff = max(dot(N, L), 0.0);
	vec3 Ka = texCol;
	float Ia = 0.5;
	vec3 cdiff = diff*Ka*Ia;

	// specular 
	vec3 Ks = vec3(1.0, 1.0, 1.0);
	float Is = 1.0;	
	vec3 R = reflect(-L, N);
	float a = 32.0;
	float spec = pow(max(dot(R, V), 0.0), a);
	vec3 cspec = spec*Ks*Is;

	// rim light 
	vec3 crim = vec3(0.0);

	if (enableRimLight) {
		float rim = (1.0 - dot(N, V));
		rim = smoothstep(0.0, 1.0, rim);
		float rim_exp = 3.5;
		rim = pow(rim, rim_exp);
		vec3 rim_col = vec3(0.1, 0.1, 0.1);
		crim = rim * rim_col;
	}


	// final color 
	color = vec4(camb + cdiff + cspec + crim, 1.0);
}
```

The main difference here is how *texCol* is obtained from the texture sampler, and set as *Ka*. Here's the output:

![textured torus](/images/2021/06/torus_textured.png)

# Procedural Textures 

GLSL give you amazing flexibility in 

- graphtoy

# Bump Mapping 

# Conclusion 

# Downloads

https://github.com/mkvenkit/nocg

# References 

1. https://www.khronos.org/registry/OpenGL-Refpages/gl4/
2. OpenGL Superbible, 7th Edition 


[1]: https://www.glfw.org/docs/latest/index.html
[2]: https://glad.dav1d.de/
[3]: https://glm.g-truc.net/0.9.9/index.html
[4]: https://github.com/nothings/stb
