---
layout: post
title: "Rendering a Torus: Geometry, Lighting, and Textures"
excerpt: "...torus."
tags: [OpenGL, C++, rendering, GLSL, shader, fragment, vertex, normal mapping, bump mapping, phong, gouraud, parameteric equation]
categories: [3D Graphics, programming]
comments: false
modified: 2021-06-19
thumbnail: /images/2021/06/torus_tn.png
---

![torus](/images/2021/06/torus.png)

# Introduction 

OpenGL 

Vulkan...


# Objective 

In this project we will render a torus using the OpenGL. 

These are the topics we will be covering in this article:

- [Project Overview](#project-overview)
- Modern OpenGL Code Structure
- Creating Axis and Plane 
- Creating the torus geometry 
- Lighting Model 
    - Gouraud Shading
    - Phong Shading 
    - Rim Lighting
- Texture Mapping 
- Procedura Textures  
- Bump Mapping 

I'll assume that you have some background in C++ and OpenGL. In my articles, I'll be mostly focusing on the math and explanation of graphics techniques. The full code listings can be found in the link in the [Downloads](#downloads) section.

Now let's get started.

# Project Overview 

We will use C++ 17 and OpenGL for this project. We will also leverage the following external 
libraries:

- [GLFW][1] - a cross platform OpenGL windowing library.
- [glad][2] - a OpenGL function loader. (Incuded in repo.)
- [glm][3] - an amazing C++ headers-only GLSL compatible library for 3D graphics math.
- [stb][4] - a single file image loading library. (Included in repo.)

This project is part of my "Notes on Computer Graphics" github repo. Please check the 
[Downloads](#downloads) section for details.

# OpenGL Setup

We will be using OpenGL 4.5 for this projects. Here's the overall rendering strategy, which is typical for OpenGL programs.

**Setup**

1. Load the required GLSL shaders. 
2. Create the geometry for the 3D object - vertices, normals, texture coordinates, etc.
3. Load textures, if applicable.
4. Create a Vertex Array Object (VAO) to 
5. Create a 

**Render**

1. Update Projection, View, and Model matrices as applicable.
2. Enable GLSL program, set *uniform* data.
3. Render the object using *glDrawArrays()* or similar calls.


# Axis and Plane 

Before we start with a torus, we'll define two other useful 

# Torus Geometry 

Here's the scheme we're going to use to represent the torus:

![torus construction](/images/2021/06/torus_constr.png)

The torus centered at the origin with it's axis aligned along $+Z$ can be described using the following set of parametric equations:

$$
\begin{aligned}
x &= (R + r \cos{v}) \cos{u} \\
y &= (R + r \cos{v}) \sin{u} \\
z &= r \sin{v}
\end{aligned}
\tag{1}
$$

Here, $$u, v \in [0, 2\pi]$$.

In Eq. 1, $$R$$ is the outer radius of the torus, $$r$$ is the tube radius, $$u$$ and $$v$$ are angles show in the figure above.

Normals are given by:

$$
\begin{aligned}
N_x &= \cos{v} \cos{u} \\
N_y &= \cos{v} \sin{u} \\
N_z &= \sin{v}
\end{aligned}
\tag{2}
$$

## Code

Here's the code, from the *Torus::_createTorus()* method:

```cpp
float du = 2 * M_PI / _nR;
float dv = 2 * M_PI / _nr;

for (size_t i = 0; i < _nR; i++) {

    float u = i * du;

    for (size_t j = 0; j <= _nr; j++) {

        float v = (j % _nr) * dv;

        for (size_t k = 0; k < 2; k++)
        {
            float uu = u + k * du;
            // compute vertex
            float x = (_R + _r * cos(v)) * cos(uu);
            float y = (_R + _r * cos(v)) * sin(uu);
            float z = _r * sin(v);

            // add vertex 
            _vertices.push_back(x);
            _vertices.push_back(y);
            _vertices.push_back(z);

            // compute normal 
            float nx = cos(v) * cos(uu);
            float ny = cos(v) * sin(uu);
            float nz = sin(v);

            // add normal 
            _normals.push_back(nx);
            _normals.push_back(ny);
            _normals.push_back(nz);

            // compute texture coords
            float tx = uu / (2 * M_PI);
            float ty = v / (2 * M_PI);

            // add tex coords
            _texCoords.push_back(tx);
            _texCoords.push_back(ty);

            // add tangent vector
            // T = d(S)/du 
            // S(u) is the circle at constant v
            glm::vec3 tg(  -(_R + _r * cos(v)) * sin(uu),
                            (_R + _r * cos(v)) * cos(uu),
                            0.0f
                        );
            tg = glm::normalize(tg);
            _tangents.push_back(tg.x);
            _tangents.push_back(tg.y);
            _tangents.push_back(tg.z);
        }
        // incr angle
        v += dv;
    }
}
```


# Lighting Model 

Here's the lighting model for our project.

![Lighting Model](/images/2021/06/lighting.png)



# Gouraud Shading 

Here's the vertex shader:

```c
#version 450 core

layout(location = 0) in vec3 aVert;
layout(location = 1) in vec3 aNorm;

uniform mat4 vMat;
uniform mat4 pMat;
uniform mat4 mMat;

out vec3 color;
out vec3 norm;


void main()
{
    // vertex in world coords
    vec3 wcVert = (vMat * mMat * vec4(aVert, 1.0)).xyz;
    // normal in world coords
    mat4 nMat = transpose(inverse(vMat * mMat));
    vec3 N = normalize((nMat * vec4(aNorm, 1.0)).xyz);

    // ambient 
    vec3 camb = vec3(0.1);

    // diffuse 
    vec3 lightPos = vec3(0.0, 0.0, 10.0);
    vec3 L = normalize(lightPos - wcVert);
    float diff = max(dot(N, L), 0.0);
    vec3 Ka = vec3(1.0, 0.0, 0.0);
    float Ia = 0.5;
    vec3 cdiff = diff*Ka*Ia;

    // specular 
    vec3 Ks = vec3(1.0, 1.0, 1.0);
    float Is = 1.0;
    vec3 R = reflect(-L, N);
    vec3 V = normalize(-wcVert);
    float a = 128.0;
    float spec = pow(max(dot(R, V), 0.0), a);
    vec3 cspec = spec*Ks*Is;

    // final color 
    color = camb  + cdiff  + cspec;

    gl_Position = pMat * vMat * mMat * vec4(aVert, 1.0);

    norm = aNorm;	
}
```

Here's the fragment shader:

```c
#version 450 core

in vec3 color;
out vec4 fragColor;

void main()
{
    fragColor = vec4(color, 1.0);    
}
```


# Phong Shading 

# Rim Lighting 

# Texture Mapping 

# Procedural Textures 

# Bump Mapping 

# Conclusion 

# Downloads

https://github.com/mkvenkit/nocg

# References 

1. https://www.khronos.org/registry/OpenGL-Refpages/gl4/
2. OpenGL Superbible, 7th Edition 


[1]: https://www.glfw.org/docs/latest/index.html
[2]: https://glad.dav1d.de/
[3]: https://glm.g-truc.net/0.9.9/index.html
[4]: https://github.com/nothings/stb
