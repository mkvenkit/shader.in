---
layout: post
title: "Rendering a Torus: Geometry, Lighting, and Textures"
excerpt: "...torus."
tags: [OpenGL, C++, rendering, GLSL, shader, fragment, vertex, normal mapping, bump mapping, phong, gouraud, parameteric equation]
categories: [3D Graphics, programming]
comments: false
modified: 2021-06-19
thumbnail: /images/2021/06/torus_tn.png
---

![torus](/images/2021/06/torus.png)

# Introduction 

OpenGL 

Vulkan...


# Objective 

In this project we will render a torus using the OpenGL. 

These are the topics we will be covering in this article:

- [Project Overview](#project-overview)
- Modern OpenGL Code Structure
- Creating Axis and Plane 
- Creating the torus geometry 
- Lighting Model 
    - Gouraud Shading
    - Phong Shading 
    - Rim Lighting
- Texture Mapping 
- Procedura Textures  
- Bump Mapping 

I'll assume that you have some background in C++ and OpenGL. In my articles, I'll be mostly focusing on the math and explanation of graphics techniques. The full code listings can be found in the link in the (#downloads) section.

Now let's get started.

# Project Overview 

We will use C++ 17 and OpenGL for this project. We will also leverage the following external 
libraries:

- [GLFW][1] - a cross platform OpenGL windowing library.
- [glad][2] - a OpenGL function loader. (Incuded in repo.)
- [glm][3] - an amazing C++ headers-only GLSL compatible library for 3D graphics math.
- [stb][4] - a single file image loading library. (Included in repo.)

This project is part of my "Notes on Computer Graphics" github repo. Please check the [Downloads](#downloads) section for details.

# Modern OpenGL Code Structure

We will be using OpenGL 4.5 for this projects. Here's the overall structure of our project. (This is a template for most modern OpenGL projects.)

1. Load the required GLSL shaders. 
2. Create the geometry for the 3D object - vertices, normals, texture coordinates, etc.
3. 


# Axis and Plane 

Before we start with a torus, we'll define two other useful 

# Torus Geometry 



A torus can be described using the following parametric equations:

$$
\begin{aligned}
x &= (R + r \cos{v}) \cos{u} \\
y &= (R + r \cos{v}) \sin{u} \\
z &= r \sin{v}
\end{aligned}
\tag{1}
$$

Normals are given by:

$$
\begin{aligned}
N_x &= \cos{v} \cos{u} \\
N_y &= \cos{v} \sin{u} \\
N_z &= \sin{v}
\end{aligned}
\tag{2}
$$

## Code

Here's the code, from the *Torus::_createTorus()* method:

```cpp
float du = 2 * M_PI / _nR;
float dv = 2 * M_PI / _nr;

for (size_t i = 0; i < _nR; i++) {
    
    float u = i * du;

    for (size_t j = 0; j <= _nr; j++) {

        float v = (j % _nr) * dv;

        for (size_t k = 0; k < 2; k++)
        {
            float uu = u + k * du;
            // compute vertex
            float x = (_R + _r * cos(v)) * cos(uu);
            float y = (_R + _r * cos(v)) * sin(uu);
            float z = _r * sin(v);

            // add vertex 
            _vertices.push_back(x);
            _vertices.push_back(y);
            _vertices.push_back(z);

            // compute normal 
            float nx = cos(v) * cos(uu);
            float ny = cos(v) * sin(uu);
            float nz = sin(v);

            // add normal 
            _normals.push_back(nx);
            _normals.push_back(ny);
            _normals.push_back(nz);

            // compute texture coords
            float tx = uu / (2 * M_PI);
            float ty = v / (2 * M_PI);

            // add tex coords
            _texCoords.push_back(tx);
            _texCoords.push_back(ty);

            // std::cout << tx << "," << ty << std::endl;

            // add tangent vector
            // T = d(S)/du 
            // S(u) is the circle at constant v
            glm::vec3 tg(  -(_R + _r * cos(v)) * sin(uu),
                            (_R + _r * cos(v)) * cos(uu),
                            0.0f
                        );
            tg = glm::normalize(tg);
            _tangents.push_back(tg.x);
            _tangents.push_back(tg.y);
            _tangents.push_back(tg.z);

            //std::cout << tg.x << "," << tg.y << "," << tg.z << std::endl;
        }

        // incr angle
        v += dv;

    }
}
```


# Lighting Model 

Here's the lighting model for our project.

![Lighting Model](/images/2021/06/lighting.png)



# Gouraud Shading 

# Phong Shading 

# Rim Lighting 

# Texture Mapping 

# Procedural Textures 

# Bump Mapping 

# Conclusion 

# Downloads

https://github.com/mkvenkit/nocg

# References 

1. https://www.khronos.org/registry/OpenGL-Refpages/gl4/
2. OpenGL Superbible, 7th Edition 


[1]: https://www.glfw.org/docs/latest/index.html
[2]: https://glad.dav1d.de/
[3]: https://glm.g-truc.net/0.9.9/index.html
[4]: https://github.com/nothings/stb
